# JavaScript

- 자바스크립트의 버전은 ECMAScript의 버전에 따라 결정된다.
- ES5, ES6 ... 등으로 일컫는다.
- 2018년 이후로 ES6이 표준으로 사용되고 있다.



## 변수 종류

- 어떤 변수를 사용하느냐에 따라 scope 변수의 유효범위가 달라진다.
- ES5까지 변수는 오로지 var 타입으로만 선언이 가능했다.



### var

- var 타입 변수는 함수의 코드 블록만을 스코프로 인정한다. 
- 스코프란 참조 대상 식별자를 찾아내기 위한 규칙이다.
- 변수가 전역에 선언되었다면 해당 변수는 어디서든 참조가 가능하다.
- 그런데 이미 선언된 변수를 함수 내에 다시 선언하면, 그 변수는 함수 내에서만 사용이 가능하다.
- 즉, 선언 위치에 따라 전역 변수가 될 수도, 지역 변수가 될 수도 있다는 것이다.
- 또한 var 타입 객체는 얼마든지 중복 선언이 가능하다.
- 이는 매 선언부마다 메모리가 재할당되기 때문이다.



#### 동적/정적 스코프

- 프로그래밍 언어는 변수를 어디에서 참조할 것인가에 따라 동적(dynamic) 스코프와 정적(lexical/static) 스코프로 나뉜다.
- 동적 스코프는 함수가 호출된 위치에 따라 상위 스코프를 결정한다.
- 정적 스코프는 함수가 선언된 위치에 따라 상위 스코프를 결정한다.
- 자바스크립트를 비롯한 대부분의 언어는 정적 스코프를 따른다.

```javascript
var x = '1';

function A() {
	var x = 'a';
	B();
}

function B() {
    console.log(x);
}

A(); // 1
B(); // 1
```

- 위 코드에서 함수 B는 전역에 선언되었다. 따라서 A() 함수 내에서 호출된 B()도, 전역에서 호출된 B()도 모두 전역 변수 값인 '1'을 출력한다. 
- 즉, 호출된 위치는 중요하지 않다는 것이다.
- 따라서 동일한 이름의 변수를 중복 선언할 때 문제가 발생하기 쉽다.
- 하나의 웹페이지에 다양한 js 파일이 로드될수록 이러한 위험은 가중된다.
- 그러므로 오류를 방지하기 위해서는 꼭 필요한 경우가 아니라면 전역변수 사용을 지양하는 것이 좋다.



#### 호이스팅

- 호이스팅이란, 변수/함수 선언문이 해당 scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다.
- 예를 들어, 변수 a를 호출하기에 앞서서 먼저 a를 선언해주어야 하는 java와는 달리, javascript에서는 그 변수 a가 호출하는 위치보다 아래에 있어도 인식된다는 뜻이다.
- 다만 이 때에는 실제로 값이 할당되지는 않았으므로 'undefined'로 나타나게 된다.



#### 변수의 생성 과정

- javascript의 var 타입 변수는 다음과 같은 생성 과정을  거친다.

1. 선언 단계 : 변수 객체에 변수를 등록한다. 스코프는 이 객체를 참조한다.
2. 초기화 단계 : 객체에 메모리를 할당한다. 이때 undefined라는 초기값을 부여받는다.
3. 할당 단계 : 실제 값을 할당한다.

- var 타입 변수는 선언 단계와 초기화 단계가 한번에 이루어진다.
- 따라서 호출하는 지점보다 변수 선언이 아래에 있다고 해도, 그 값은 not defined(변수 없음)가 아니라 undefined(변수 값 없음)가 된다.



### let

- let은 쉽게 말해 지역변수이다.

- var가 전역 변수로서 남용될 수 있다는 단점을 보완하기 위해 나온, 정적 스코프를 따르는 객체이다.

- 따라서 let으로 정의된 객체의 값은 블록 내부에서만 유효하다.

- 이 let이 일반적으로 java에서 사용되는 변수라고 보면 된다.

- 같은 이유로, let을 이용하여 같은 변수를 중복 선언하면 오류가 발생하게 된다.

  

### const

- const는 java의 static 객체와 유사하게 블록 레벨 스코프를 지닌다.
- 대부분 let과 비슷한 성질을 지녔으나, static처럼 재할당이 금지된다.
- 또한 선언과 동시에 값을 부여받아야 한다.



## 연산자

- ()를 통해 우선순위를 부여할 수 있다.
- +, -, *, /, % 연산자를 사용한다.
- ||, && 같은 논리 연산자를 사용한다.
  - 이때 || 연산자는 왼쪽 값이 충족되면, 오른쪽 값은 판단하지 않는다.
  - 단 undefined라면 오른쪽 값을 판단한다.
- '조건 ? true : false' 의 삼항 연산자를 사용할 수 있다.
- '같다'라는 비교 연산자는 ==보다 ===을 사용한다. (오류가 많이 발생한다)
  - == 은 '타입'을 바꾸어서 판단한다.
  - === 은 '타입'까지 같은지 판단한다.



## 타입

- 타입은 선언 시가 아니라, 실행 시에 결정된다.
- 이는 위에서 설명한 변수의 생성 과정과 유사한 맥락에서 이해될 수 있다.
- 즉, 미리 변수를 설정하지 않고 선언하더라도 크게 문제가 없다.
- toString.call()이나 typeof()를 통해 명시적으로 확인하는 방법도 있다.



## 함수

- 함수는 여러 개의 인수를 받아서 그 결과를 출력한다.
- 파라미터의 개수와 인수의 개수가 일치하지 않아도 오류가 나지 않는다.
- 이럴 경우 파라미터는 undefined라는 값을 자동으로 가지게 된다.
- 파라미터가 더 많을 경우 자동으로 무시된다.
- 즉, 기본적으로 오류가 잘 나지 않는다.



```javascript
function printName(firstname) {
    return "my name is " + firstname;
}

console.log(printName());
```

> my name is undefined



### 함수 표현식

```javascript
function printName(firstname) {
    
    var result = inner();
        console.log("my name is " + result);
    
  	function inner() {
        return "inner value";
    }
}

printName();
```

> my  name is inner value

- 함수 선언부가 아래에 나와있다고 하더라도 같은 중괄호 내에서 함수로 인식되고 있다 -> 위에서 다룬 호이스팅 개념
- 즉, 함수가 실행되기 전에 함수 전체의 내용을 훑어서 확인하는 절차가 진행되는 것



### 함수의 리턴값

- js는 아무 것도 eturn하지 않아도 기본적으로 undefined를 반환한다.
- 즉, 자바에서의 void 같은 함수는 없다.



### arrow function

- ES2015에 추가된 기능이라고 한다.

```javascript
function getName(name) {
   return "Kim " + name ;
}

//위 함수는 아래 arrow함수와 같다.
var getName = (name) => "Kim " + name;
```

- 점점 많이 사용되고 있는 추세라고 한다.