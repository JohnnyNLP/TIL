# Application for Algorithm



## int형 숫자의 자릿수 구하기

- String 객체의 경우, 길이를 구하기 위해 String.length() 함수를 이용할 수 있다.
- 그러나 이와 유사한 Integer 객체의 .SIZE()라는 함수는 해당 정수의 바이트 값을 return해주는 다른 용도의 함수이다.
- int의 자릿수를 구하기 위해서는 수학적 접근 방식을 취해야 한다.

```java
int length = (int)(Math.log10(a)+1);
```

- 밑이 10인 로그는 해당 정수에 10이 총 몇번 곱해졌는지를 알려준다.
- 즉, 일의 자릿수를 제외한 자릿수의 개수인 셈이다.
- 그러므로 총 자릿수는 그 값에 1을 더해주어야 한다.
- 그런데 Math.log() 함수의 return 값은 double이기 때문에 int로 형변환 해주어야 한다.



## 자릿수의 합 구하기

- 기존에 자릿수의 합을 구하는 문제에서는 주어진 숫자가 두/세자리 수였기 때문에 10/100으로 나눈 값을 임의의 문자에 할당하여 일일이 더해주었다.
- 그러나 while 문을 이용하면 한번에 특정 숫자의 자릿수 합을 구할 수 있다는 것을 알게 되었다.

```java
while(temp!=0) {		
    sum += temp%10;
	temp /= 10;
}
```

- 간단한 수식이지만, num에 원하는 숫자를, sum에 0을 대입해두면 sum에 알아서 자릿수의 합이 차곡차곡 쌓인다.
- 나머지 정리를 이용한 방법으로, 수행 방식은 다음과 같다.
  1. temp를 10으로 나눈 나머지는 temp의 일의 자리 수이다.
  2. 이를 sum에 더해서 저장한다.
  3. temp를 10으로 나눈 값을 자기 자신에게 재할당한다.
  4. 이때 temp는 일의 자리 수가 지워진 값으로 저장된다.
- 이렇게 일의 자릿수부터 지워나가며 sum에 더하면 최종적으로 0이 되어 while문을 벗어난다.



## 리스트의 특정 값 지우기

- list.remove() 함수의 인자에는 두 가지가 들어갈 수 있다.
- 보통 우리가 사용하는 int 인자를 대입할 경우, list의 n번 인덱스의 값을 제거하게 된다.
- 그러나 이 경우에는 num라는 구체적인 값에 대응하는 원소를 지워야 한다는 점과, 지워나갈 때마다 list의 인덱스 역시 변화한다는 점을 고려해야 한다.

```java
list.remove((Integer) num);
```

- 이때 인자 앞에 **(Integer)**를 적어서 명시적 형변환을 해주면 우리가 원하는 대로 해당 값과 일치하는 원소를 지우게 된다.



## 배열의 초기 변수값 지정하기

```java
int[] array = new int[n]
```

- 다음은 정수 타입을 저장하는 n개의 원소를 지니는 배열의 생성문이다.
- 다음과 같이 배열을 생성했을 경우, 배열 안에 n개의 주소값이 부여되지만, 그 값은 아직 0인 상태이다.
- 이 때 일률적으로 배열값을 0이 아닌 다른 값으로 부여하고 싶다면 Arrays 클래스의 fill 함수를 사용한다.

```java
Arrays.fill(array, 1)
```

- 그러면 int의 모든 주소값에 1이라는 값이 부여된다.



## 최대공약수, 최소공배수 구하기

- 유클리드 호제법이란 두 자연수의 최대공약수를 구하는 알고리즘이다.

```java
	public static int lcm (int M, int N) {
		int big=M, small=N, r=1;
		if(M < N) {
			big = N;
			small = M;
		}
        
        // 유클리드 호제법
		while (r>0){
			r =  big % small;
			big = small;
			small = r;
		}
        
		return M*N/big;
	}
```

- 먼저 두 자연수 M과 N에 대하여, 큰수와 작은수를 판별해준다.
- 이후 r에 아무 값이나 부여한 뒤에, while문을 이용하여 계속해서 나누어줄 것이다.
- 최초 r에 큰수를 작은수로 나눈 몫을 부여하는데, 이때 이 r이 0이 되는 시점이 두 수가 나누어 떨어질 때이다.
- 이후 큰 수에 작은 수를, 작은 수에 r을 대입한 후 loop로 돌린다.
- while 문이 종료되었을 때 big에 저장된 값이 최대공약수가 된다.
- 최소공배수는 원래 두 수의 곱에 최대공약수를 나누면 된다.

>M=12, N=15일 때
>
>| r         | big            | small                     |
>| --------- | -------------- | ------------------------- |
>| 최초 시행 | 15             | 12                        |
>| 3         | 12             | 3                         |
>| 0         | 3              | 0                         |
>| break     | 최대공약수 : 3 | 최소공배수 : 15*12/3 = 60 |

