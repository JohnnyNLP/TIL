# 파이썬 스터디

## 2019. 06. 24.

### 주피터 노트북

- 오픈소스 웹 애플리케이션
- python + shell
- 데이터 분석에 주로 쓰임 -> 시각화 용이
- 데이터 전처리에 유리함
- 40개 이상의 언어 제공
- 시각화 패키지 다루기 수월
- 코드 실행 결과를 바로바로 확인 가능



## 2019. 06. 26.

### regular expression (정규표현식)

- 재귀 열거 언어 -> 문맥 의존 언어 -> 문맥 자유 언어 -> 정규 언어 (촘스키)
- 우리가 쓰는 언어는 문맥 의존 언어
- 컴퓨터 언어는 문맥 자유 언어
- 정규 언어는 문맥에서 자유로운 대신 제한된 규칙을 따른다.
- 복잡한 문자열을 처리할 때(자연어 처리) 사용한다.



```python
import re

data = """
park 800906-1049118
kim  700905-1059119
"""

pat = re.compile("(\d{6})[-]\d{7}")
print(pat.sub("\g<1>-*******", data))

```

> park 800906-*******
> kim 700905-*******



#### 메타 문자

- 원래 문자가 가진 뜻과 다르게 사용되는 문자
- [abc] : a, b, c 중 적어도 하나
- [a-zA-Z0-9] : 문자+숫자 모두 (\w)
- [a-zA-Z] : 알파벳 전체
- [0-9] : 모든 숫자 (\d)
- [^0-9] : 숫자 제외 (\D)
- \s : 화이트 스페이스 -> 공백, 탭, 줄바꿈 모두 포함
- \n : 줄 바꿈
- a.b : a와 b 사이에 [모든 문자] => (\n)을 제외한 모든 문자
- a[.]b : a.b
- 메타 문자를 문자 그대로 사용하고 싶다면 [] 안에 써주면 된다.
- ca*t : c와 t 사이에 a가 0번부터 무한히 많이 올 수 있다. (ex) ct, cat, caat...) {0, }
- ca+t : a가 최소 한 번 등장해야 한다. (ex) cat, caat, caaat...) {1, }
- ca?t : a가 0번 또는 1번 반복 (ex) ct, cat) {0, 1}
- ca{n}t : a가 n번 등장해야 한다.
- ca{n, }t : a가 최소 n번 이상 등장해야 한다.
- ca{, n}t : a가 0번~n번 등장해야 한다.
- ^python : python으로 시작. 각 줄마다 매칭
- language$ : language로 끝남. 각 줄마다 매칭
- \Apython : python으로 시작. 첫 줄만 매칭
- language\Z : language로 끝남. 마지막 줄만 매칭
- (ABC)+ : ABC가 한 묶음으로 1회 이상 반복 (ex) ABC, ABCABC, ABCABCABC...)



#### 정리

- { } : 반복 횟수 지정

- []: 괄호 안을 문자로 인식

- ( ) : 괄호 안 문자를 묶음으로 인식

- +: 최소 한 번 등장 {1, }

- *: 0번부터 무한 번 등장 {0, }

- ? : 0번 혹은 1번 등장 {0, 1}

  

#### re 모듈

- pattern = re.compile('정규표현식') : 따옴표 안의 정규표현식으로 객체를 하나 생성한다.
- pattern.match('실제 텍스트') : match의 변수로 전달한 문자가 pattern의 정규표현식과 일치하는지 확인한다.
- re.match('정규표현식', '실제 텍스트') : 위 두 코드를 동시에 실행한 효과.
- 이때 match가 되지 않으면 반환 값이 none이다.
- 반환값은 실제 텍스트에서 표현식에 해당하는 문자열의 인덱스를 슬라이싱해서 보여준다.
- 그런데 match는 해당 문자열이 0부터 시작해야만 발견할 수 있다.
- 만약 문자열이 중간에 등장한다면 search 함수를 사용한다.



#### re 모듈의 함수

##### 패턴 객체

- p = re.compile('정규표현식')으로 매치시킬 정규표현 객체를 생성한다.
- p.match()와 p.search()는 처음/전체에서 최초로 매칭되는 값만 리턴한다.
- p.findall()은 매치되는 모든 문자열을 리스트로 반환한다.
- p.finditer()은 매치되는 모든 문자열을 iterator (match object로 이루어진 리스트)로 반환한다. => 매치된 문자열의 인덱스를 추출할 수 있다.
- p.sub()는 매치되는 모든 문자열을 특정 문자열로 변환한다.



##### 매치 객체

- m = p.match('정규표현식')으로 매치 객체를 만들면, 이에 대해서 또다른 함수 기능 수행이 가능해진다.
- m.group()은 매치된 문자열을 반환한다.
- m.start()은 매치된 문자열의 시작 인덱스를 반환한다.
- m.end()는 매치된 문자열의 끝 인덱스를 반환한다.
- m.span()은 매치된 문자열의 시작과 끝 인덱스를 반환한다.



```python
text = "에러 1122 : 레퍼런스 오류\n 에러 1033: 아규먼트 오류"
regex = re.compile("에러 1033")
mo = regex.search(text)
if mo != None :
    print(mo.group())
    print(mo.span())
```

> 에러 1033
>
> (19, 26)



```python
text = '문의사항이 있으면 032-232-3245로 연락주시기 바랍니다.'
regex = re.compile(r'\d{2,3}-\d{3,4}-\d{4}')
matchobj = regex.search(text)
phonenumber = matchobj.group()
print(phonenumber)
#r은 뒤에 나온 '\ << 얘를 혼동하지 않도록 문자 그대로 해석하라는 의미
```

> 032-232-3245



## 2019. 07. 01.

### 예외 처리

- 예외 = 오류
- 예외가 왜 발생했는지를 이해하고 이러한 상황이 일어날 수밖에 없을 때 예외처리를 적절히 해낼 수 있어야 한다.
- 예외를 적절하게 처리하지 않으면 프로그램이 멈춘다!
- try, except구문

```python
# 예시 1
text = '200%'
try:
    number=int(text)
except ValueError:
    print('{}는 숫자가 아니잖아요'.format(text))
```

> 200%는 숫자가 아니잖아요

```python
# 예시 2
def safe_pop_print(list, index):
    try:
        print(list.pop(index))
    except IndexError:
        print('index:{}인 값 없음'.format(index))
    
safe_pop_print([1, 2, 3], 5)
```

> index:5인 값 없음

- 오류가 여러 종류 발생할 때에는 except 뒤를 비워두면 된다.

```python
# 예시 3
try:
    list=[]
    print(list[0]) #IndexError
    text='abc'
    number=int(text) #invalid literal
except:
    print('오류가 발생했습니다.')
```

> 오류가 발생했습니다.

- 에러의 정체를 밝히고 싶다면 다음과 같이 바꾸면 된다. (단, 최초 1회 오류만 검사한다.)

```python
except Exception as ex :
    print('오류가 발생했습니다.', ex)
```

> 오류가 발생했습니다. list index out of range

- 에러를 일부러 발생시킬 수도 있다.

```python
# 예시 4
def rsp(mine, yours):
    allowed=['가위','바위','보']
    if mine not in allowed :
        raise ValueError
    if yours not in allowed :
        raise ValueError
rsp('가위', '바')
```

> Traceback (most recent call last):
>   File "exception_and_if.py", line 33, in <module>
>     rsp('가위', '바')
>   File "exception_and_if.py", line 32, in rsp
>     raise ValueError
> ValueError

- 위 함수가 정의된 상태에서 try-except로 예외처리를 해줄 수도 있다.

```python
# 예시 5
try:
    rsp('가위', '바')
except ValueError:
    print('잘못된 값을 넣었습니다.')
```

> 잘못된 값을 넣었습니다.



### 중첩포문을 한번에 빠져나가는 방법

- 중첩포문에서 break를 사용하면 최초 for문만 벗어나게 된다. 그런데 이때 에러를 발생시키면 for문을 완전히 나갈 수 있다.

```python
classrooms = {'1반':[162, 175, 198, 137, 145, 199], '2반':[165, 177, 157, 160, 191]}
for class_id, heights in classrooms.items():
    for height in heights:
        if height>190:
            print(class_id, '에 190이 넘는 학생이 있습니다')
            raise StopIteration
```

> 1반 에 190이 넘는 학생이 있습니다
> Traceback (most recent call last):
>   File "exception_and_if.py", line 47, in <module>
>     raise StopIteration
> StopIteration



### if문

- if : 첫 조건문에 해당될 때 수행할 코드
- elif : 두번째 ... n번째 조건에 해당될 때 수행할 코드
- else : 그 어떤 조건에도 해당되지 않을 때 수행할 코드
- 조건문에 논리연산자로 True or False 값을 검사한다.



### 논리 연산자

- and : 맨앞조건이 False이면 바로 중단한다.
- or : 맨앞조건이 True이면 바로 실행한다.
- => 단락 평가
- bool() 함수로 True, False 값을 판별할 수 있다.
- 정수/실수는 0이면 False, 아니면 True
- 리스트는 빈 리스트는 False, 나머지는 True
- 문자열의 경우 빈 문자열(None)은 False, 나머지는 True



#### 